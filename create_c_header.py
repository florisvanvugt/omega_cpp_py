import struct
import re

# This script will read the shared memory specification
# and then output a header/source file to be compiled together
# with the robot code so that the shared memory is accessible
# and the different fields are in place.

# Read the shared memory specification
f = open('shared_memory_specification.txt','r')
fw = open('struct_shm.h','w')
variables = f.readlines()
f.close()

sizeshm = 0
for var in variables:
    nm,tp = var.strip().split(' ')

    sizeshm += struct.calcsize(tp)

    # if (tp == 'd'):
    #     sizeshm += 8
    # elif (tp == 'i'):
    #     sizeshm += 4
    # else:
    #     try:
    #         type_tab, size_tab = tp.strip(']').split('[')
    #         if (type_tab == 'd'):
    #             sizeshm += int(size_tab)*8
    #         elif (type_tab == 'i'):
    #             sizeshm += int(size_tab)*4
    #     except ValueError:
    #         print("Not a good type in shared_memory_specification.txt")


def conversion_py_cpp(tp):
    if (tp == 'd'):
        return 'double'
    elif (tp == 'i'):
        print("WARNING: If you use an int, Python may not compute the address correctly (see README)")
        return 'int'
    elif (tp == 'q'):
        return 'long int'

fw.write("// DO NOT EDIT THIS FILE, AUTO-GENERATED BY create_c_header.py\n")

#fw.write("#include <vector>\n")
fw.write("#define SHM_FILESIZE " + str(sizeshm) + "\n\n")
fw.write("using namespace std;\n\n")
fw.write("struct shm_t {\n")

for var in variables:
    nm,tp = var.strip().split(' ')
    mat = re.match(r'(\d+)*([a-z])',tp)
    size_tab, type_tab = mat.groups()
    typevar = conversion_py_cpp(type_tab)
    if mat: #If variable found
        if size_tab: #If variable's size is more than 1
            nm += '[%s]'%size_tab #+ size_tab + ']'
    else:
        print("Variable not found.")

    fw.write("\t%s %s;\n"%(typevar,nm))


fw.write("};\n")

fw.close()
