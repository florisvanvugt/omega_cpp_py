import struct
import re
import sharedmem
import yaml

# This script will read the shared memory specification
# and then output a header/source file to be compiled together
# with the robot code so that the shared memory is accessible
# and the different fields are in place.

# Read the shared memory specification
sharedmem.init_specifications('.')



def convert_py_cpp(tp):
    """ Convert a python-style variable specification
    into the corresponding c-style variable specification. """
    if (tp == 'd'): return 'double'
    elif (tp == 'i'):
        print("WARNING: If you use an int, Python may not compute the address correctly (see README)")
        return 'int'
    elif (tp == 'q'): return 'long int'



fw = open('struct_shm.h','w')
fw.write("// DO NOT EDIT THIS FILE, AUTO-GENERATED BY create_c_header.py\n")
fw.write("using namespace std;\n\n")


for (label,var_order,spec) in zip(['instr','live'],sharedmem.variable_order,sharedmem.specifications):
    pathb ='struct shm_'
    patha ='_t{\n'
    path = 'struct shm_'+label+'_t{\n'
    fw.write(path)
    sizeshm = 0
    for nm in var_order:
        tp,_,sz  = spec[nm]

        # Determine whether this type is an array; if so, make the correct C type specification
        mat = re.match(r'(\d+)*([a-z])',tp)
        size_tab, type_tab = mat.groups()
        typevar = convert_py_cpp(type_tab)
        if mat: #If variable found
            if size_tab: #If variable's size is more than 1
                nm += '[%s]'%size_tab #+ size_tab + ']'
        else:
            print("Variable not found.")

        fw.write("\t%s %s;\t // memory offset %i \n"%(typevar,nm,sizeshm))

        # Keep track of the size
        sizeshm += sz


    fw.write("};\n")
    fw.write("#define SHM_%s_FILESIZE %s\n\n"%(label.upper(),sizeshm))



fw.close()

# This script will output a source/header file with the function
# new_instruction to be compiled together
# with the robot code




variable_groups = "./variable_groups.yaml"
fw = open('instruction.cpp','w')
fw.write("// DO NOT EDIT THIS FILE, AUTO-GENERATED BY create_c_header.py\n")
fw.write ("#include \"instruction.h\" \n ")
fw.write ("#include \"struct_shm.h\" \n ")
fw.write ("#include <iostream> \n ")
fw.write ("\n\n")
fw.write("void new_instruction(shm_instr_t* sh_instr_memory, shm_live_t* sh_live_memory) { \n")
fw.write ("\t int prefix = sh_instr_memory->prefix ;\n")
fw.write("\t sh_live_memory -> instruction_no = sh_instr_memory -> instruction_no; \n")
with open(variable_groups,'r') as f:
    groups = yaml.load(f)
    for prefix,group in groups.iteritems():   # Progress lign by lign in the shared_memory_specification
            fw.write("\t if (prefix == %d ) {\n " %prefix)
            for var in group :
                fw.write("\t\t sh_live_memory -> %s = sh_instr_memory -> %s; \n"%(var,var))
            fw.write("\t}\n")
    fw.write("}\n")
    fw.write ("\n\n")


fw.write("void new_trajectory(shm_instr_t* sh_instr_memory, shm_live_t* sh_live_memory) { \n")
fw.write("int i; \n")
fw.write("int n = sh_instr_memory->trajectory_size; \n")
fw.write("for (i=0;i<n;i++){ \n")
for nm in ['x', 'y', 'z']:
    fw.write("\t (sh_live_memory -> trajectory_%s)[i] = (sh_instr_memory -> trajectory_%s)[i]; \n"%(nm,nm))
fw.write ("\t }\n")
fw.write ("}\n")
fw.close()
